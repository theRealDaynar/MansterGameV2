<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///generate terrain
area_size = 60
room_width = area_size * 32
room_height = area_size * 32

randomize()

//define different types of terrain
enum terrain
{
//do nothing
air = 0,
//sink
deep_water,
//sink give off light and damage
lava,
//solids
rock,
dirt,
//solid show footprints
sand,
snow,
//solid show ripples and sink slightly
shallow_water,
//solid slide
ice
}

island_grid = ds_grid_create(area_size,area_size)
var section_size = area_size div 3
ds_grid_set_region(island_grid,0,0,section_size,area_size * .5,terrain.dirt)
ds_grid_set_region(island_grid,section_size,0,section_size * 2,area_size * .5,terrain.rock)
ds_grid_set_region(island_grid,section_size * 2,0,area_size,area_size  * .5,terrain.snow)
ds_grid_set_region(island_grid,0,area_size * .5,section_size,area_size,terrain.sand)
ds_grid_set_region(island_grid,section_size,area_size * .5,section_size * 2,area_size,terrain.shallow_water)
ds_grid_set_region(island_grid,section_size * 2,area_size * .5,area_size,area_size,terrain.deep_water)

repeat(irandom_range(7,20))
{
    x = random(room_width)
    y = random(room_height)
    repeat(irandom_range(4,20))
    {
        instance_create(x + random_range(-100,100),y + random_range(-100,100),oGrass)
    }
}

//var p = get_p()
//var p = GeneratePerlinNoise(GenerateWhiteNoise(area_size,area_size),5)
//for(y = 0; y &lt; area_size; ++y)
//for(x = 0; x &lt; area_size; ++x)
//{
//    var noise = /*perlin(x/area_size - .5, y/area_size - .5,.2,p);*/octave_perlin(x / area_size-.5,y / area_size-.5,sqrt(sqr(x-area_size/2) + sqr(y-area_size/2))/sqrt(2*sqr(area_size/2)),1,.5,p);
       
        //var noise = p[#x,y];
//        island_grid[#x,y] = noise;
        /*
        if noise &gt; .9
            island_grid[#x,y] = terrain.ice
        else if noise &gt; .7
            island_grid[#x,y] = terrain.snow
        else if noise &gt; .5
            island_grid[#x,y] = terrain.rock
        else if noise &gt; .3
            island_grid[#x,y] = terrain.dirt
        else if noise &gt; .2
            island_grid[#x,y] = terrain.sand
        else if noise &gt; .1
            island_grid[#x,y] = terrain.shallow_water
        else
            island_grid[#x,y] = terrain.deep_water
    
*/
//}

/*terrain_grids = ds_list_create()
repeat(5)
ds_list_add(terrain_grids,ds_grid_create(area_size,area_size))
//bottom cave layer generation
bottom_cave_grid = terrain_grids[|4]
var padding = ceil(area_size * .1)
var padded_total = area_size - padding
for(y = padding; y &lt; padded_total;++y)
for(x = padding; x &lt; padded_total;++x)
{
    if random(100) &gt; 52
        bottom_cave_grid[#x,y] = terrain.rock   
}
var padding2 = ceil(padding * .1)
var padded2_total = area_size - padding2
repeat(4)
for(y = padding2; y &lt; padded2_total;++y)
for(x = padding2; x &lt; padded2_total;++x)
{
    var total_1_step = 0
    var total_2_step = 0
    for(var yy = y - 2; yy &lt;= y + 2;++yy)
    for(var xx = x - 2; xx &lt;= x + 2;++xx)
    {
        if bottom_cave_grid[#xx,yy] = terrain.air
        {
            ++total_2_step
            if abs(x - xx) &lt; 2 and abs(y - yy) &lt; 2
                ++total_1_step
        } 
    }   
    if total_1_step &gt;= 5 or total_2_step = 0
        bottom_cave_grid[#x,y] = terrain.air
    else
        bottom_cave_grid[#x,y] = terrain.rock
}

repeat(4)
for(y = padding2; y &lt; padded2_total;++y)
for(x = padding2; x &lt; padded2_total;++x)
{
    var total = 0
    for(var yy = y - 1; yy &lt;= y + 1;++yy)
    for(var xx = x - 1; xx &lt;= x + 1;++xx)
    {
        total += (bottom_cave_grid[#xx,yy] = terrain.air)
    }   
    if total &gt;= 5
        bottom_cave_grid[#x,y] = terrain.air
    else
        bottom_cave_grid[#x,y] = terrain.rock
}
*/
/*
//generate island
island_grid = ds_grid_create(area_size,area_size)//terrain_grids[|3]
var p = GeneratePerlinNoise(GenerateWhiteNoise(area_size,area_size),3)
var mnt_linex = ds_list_create()
var mnt_liney = ds_list_create()
repeat(irandom_range(3,10))
{
ds_list_add(mnt_linex,random_range(-.4,.4))
ds_list_add(mnt_liney,random_range(-.4,.4))
}
var ocn_linex = ds_list_create()
var ocn_liney = ds_list_create()
repeat(irandom_range(3,10))
{
ds_list_add(ocn_linex,random_range(-.4,.4))
ds_list_add(ocn_liney,random_range(-.4,.4))
}
var pln_linex = ds_list_create()
var pln_liney = ds_list_create()
repeat(irandom_range(3,10))
{
ds_list_add(pln_linex,random_range(-.5,.5))
ds_list_add(pln_liney,random_range(-.5,.5))
}

for(y = 0; y &lt; area_size; ++y)
for(x = 0; x &lt; area_size; ++x)
{
    var noise = p[#x,y];
    //island_grid[#x,y] = noise
    var d2 = distance_squared(x,y,area_size)
    var d1 = point_distance_list((x-area_size/2)/(area_size/2),(y-area_size/2)/(area_size/2),mnt_linex,mnt_liney)
    var d3 = point_distance_list((x-area_size/2)/(area_size/2),(y-area_size/2)/(area_size/2),ocn_linex,ocn_liney)
    var d4 = point_distance_list((x-area_size/2)/(area_size/2),(y-area_size/2)/(area_size/2),pln_linex,pln_liney)
    noise = lerp((noise + .5) * (1 - 7*power(d1, 3.5)) * d3 * 1.5,.5,(1-d4) * .1)
    
    if 1//noise &gt; .3 + .4 * d1
    {
        if noise &gt; .9
            island_grid[#x,y] = terrain.ice
        else if noise &gt; .7
            island_grid[#x,y] = terrain.snow
        else if noise &gt; .5
            island_grid[#x,y] = terrain.rock
        else if noise &gt; .3
            island_grid[#x,y] = terrain.dirt
        else if noise &gt; .2
            island_grid[#x,y] = terrain.sand
        else if noise &gt; .1
            island_grid[#x,y] = terrain.shallow_water
        else
            island_grid[#x,y] = terrain.deep_water
    }
    else
        island_grid[#x,y] = terrain.deep_water//*/
/*}
ds_grid_destroy(p)



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var x_max = ceil((view_xview + view_wview) / 32)
var y_max = min(ceil((view_yview + view_hview) / 32)+2,area_size)
for(y = view_yview div 32; y &lt; y_max;++y)
for(x = view_xview div 32; x &lt; x_max;++x)
{
    switch(island_grid[#x,y])
    {
        case terrain.deep_water:
            draw_rect_tile(x,y,32,c_blue)
        break;
        case terrain.shallow_water:
            draw_rect_tile(x,y,32,c_aqua)
        break;
        case terrain.sand:
            draw_rect_tile(x,y,32,c_yellow)
        break;
        case terrain.dirt:
            draw_rect_tile(x,y,32,c_green)
        break;
        case terrain.rock:
            draw_rect_tile(x,y,32,c_dkgray)
            //draw_rect_tile(x,y-1,32,c_gray)
        break;
        case terrain.snow:
            draw_rect_tile(x,y,32,c_dkgray)
            //draw_rect_tile(x,y-1,32,c_white)
        break;
        case terrain.ice:
            draw_rect_tile(x,y,32,c_dkgray)
            //draw_rect_tile(x,y-1,32,c_ltgray)
        break;
    }
}
//*/
/*
for(y = 0; y &lt; area_size;++y)
for(x = 0; x &lt; area_size;++x)
{
    //draw cave layer
    //if  bottom_cave_grid[#x,y] = terrain.rock       
    //    draw_rectangle_colour(x * 32, y * 32,x * 32 + 31,y * 32 + 31,c_gray,c_gray,c_gray,c_gray,false)
    //draw island layer
    //draw_set_color(c_white)
    //draw_text(x * 32, y * 32,island_grid[#x,y])
    //draw_set_color(c_white)
    //draw_set_alpha(island_grid[#x,y])
    //draw_rectangle(x * 32, y * 32,x * 32 + 31,y * 32 + 31,false)
    switch(island_grid[#x,y])
    {
        case terrain.deep_water:
            draw_rect_tile(x,y,32,c_blue)
        break;
        case terrain.shallow_water:
            draw_rect_tile(x,y,32,c_aqua)
        break;
        case terrain.sand:
            draw_rect_tile(x,y,32,c_yellow)
        break;
        case terrain.dirt:
            draw_rect_tile(x,y,32,c_green)
        break;
        case terrain.rock:
            draw_rect_tile(x,y,32,c_gray)
        break;
        case terrain.snow:
            draw_rect_tile(x,y,32,c_white)
        break;
        case terrain.ice:
            draw_rect_tile(x,y,32,c_ltgray)
        break;
    }//*/
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
